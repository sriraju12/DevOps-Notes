Maven Lifecycle:

The Maven build lifecycle is a structured, standardized sequence of phases that automate the process of building, testing, and deploying a project.
It ensures tasks like compiling code, running tests, and packaging artifacts are executed in the correct order. The entire lifecycle is defined in 
the project's pom.xml (Project Object Model) file.

* Lifecycle: A complete process for building and managing a project. Maven has three built-in lifecycles:

    default: The primary lifecycle for building and deploying the project.
    
    clean: A simple lifecycle for cleaning up a project by removing files generated by a previous build.
    
    site: Manages the creation and deployment of a project's documentation.


* The default lifecycle is the most commonly used and consists of numerous phases, with the most important ones being:

    validate: Validates that the project is correct and all necessary information is available.
    
    compile: Compiles the source code of the project.
    
    test: Runs unit tests on the compiled source code.
    
    package: Takes the compiled code and packages it into a distributable format like a .jar or .war file.
    
    verify: Runs checks to ensure the package meets quality criteria, often including running integration tests.
    
    install: Installs the packaged artifact into the local Maven repository for use as a dependency in other local projects.
    
    deploy: Deploys the final artifact to a remote repository for sharing with other developers and projects.



* what is the difference between mvn install and mvn package    

mvn package:
            it compiles the source code, runs tests, and packages the compiled code into a distributable format (like a .jar or .war file) in the project's target directory.

            * When you run mvn package, Maven executes the validate, compile, test, and package phases.

            * Where it puts the artifact: The artifact is placed in the project's target directory.

mvn install:
            it does all of the above and also copies the packaged artifact to your local Maven repository (~/.m2/repository). This makes the artifact available as a dependency
            for other Maven projects on your machine without needing to be deployed to a remote repository.

            * When you run mvn install, Maven executes the validate, compile, test, package, verify, and install phases.

            * Where it puts the artifact: In the project's target directory and in the local Maven repository (by default, ~/.m2/repository).

mvn deploy:
           * What it does: Everything that mvn install does, plus it copies the packaged artifact to a remote repository.

           * Where it puts the artifact: In the project's target directory, the local Maven repository, and a remote repository (like a company's Nexus or Artifactory server).





how does maven deploy the artifact in nexus repository:

* mvn deploy: 
             This is the core command that compiles, packages, and uploads the artifact. It looks for deployment information in your pom.xml or Maven's settings.xml.

             To configure Maven for Nexus, you should place repository information in your pom.xml and server credentials in your settings.xml.

  pom.xml:
          The pom.xml file is for project-specific configurations. You should define the URLs for your Nexus repositories here using the <distributionManagement> tag.
          This tells Maven where to deploy the artifacts for a specific project.

  settings.xml:
               The settings.xml file is for user-specific and machine-specific configurations. You should place your Nexus credentials in this file using the <servers> tag.
               This is the correct and secure location for usernames and passwords, as it keeps them separate from the project's source code


Maven Interview Questions:

1. Explain the Maven Project Object Model (POM) and the concept of the Super POM.

   The POM (pom.xml) is the fundamental unit of work in Maven. It contains project metadata and configuration details.
   The Super POM is Maven's default base POM, from which all other POMs inherit. It provides standard configurations like 
   the default directory structure, repository locations (Maven Central), and a default set of plugins. The final effective POM 
   is a merged result of the Super POM, the Parent POM, and the Project POM.


2. What does "Convention over Configuration" mean in Maven, and how does it save time in a DevOps environment?

   Convention over Configuration" means Maven provides smart default settings for your project structure (like placing source code in src/main/java) 
   so you don't have to configure it. Developers only write configuration for things that deviate from these standards. This standardization saves time
   in DevOps by making project setup minimal and build pipelines consistent, reliable, and easy to automate across many projects. It lets the team focus
   on coding instead of repetitive configuration tasks.


 3. Describe the Maven Build Life Cycles (Clean, Default, Site) and name the key phases you'd typically run in a CI pipeline.

   Maven has three built-in life cycles:
   * Clean (to clean the previous build)
   * Default (to build the project)
   * Site (to create project documentation). 
   In CI, we usually run: validate, compile, test, package, verify, and install or deploy (the later for publishing to a remote repository).


4. Differentiate between the usage of <dependencyManagement> and <dependencies> in a multi-module project.

   * <dependencyManagement> is placed in the parent project and is used to declare versions for dependencies, ensuring all child modules
     use the same version without inheriting the library itself. 
     
   * Conversely, <dependencies> lists the libraries a specific module actually needs to use for compiling and running its code. 
     When a child module lists a dependency here, it doesn't need to specify the version if the parent already declared it in <dependencyManagement>. 
     The main goal of <dependencyManagement> is consistent versioning across the whole multi-module project.


5. What is a Maven Repository? List the three types and their lookup order.

   A Maven repository is a directory where all project artifacts (libraries, JARs, WARs) and metadata are stored.
   The lookup order is:
   1. Local Repository (on the developer/CI machine).
   2. Central Repository (maintained by the Maven community, e.g., Maven Central).
   3. Remote/Internal Repository (hosted by the organization, e.g., Nexus/Artifactory).


6. Explain the difference between a SNAPSHOT and a RELEASE version in terms of deployment and immutability.

   A SNAPSHOT version (1.0-SNAPSHOT) is mutable and meant for active development. Its deployment artifact is not permanent and is timestamped,
   meaning dependencies automatically check for and download newer versions multiple times a day. A RELEASE version (1.0) is immutable and final,
   representing a stable point in time. Once deployed to a release repository, its content can never change, ensuring all future builds that use it are perfectly repeatable.

   
7. As a Release Engineer, how do you manage versioning and tagging using Maven's standard tooling for a release?

   I manage versioning and tagging using the maven-release-plugin, which automates the immutable release process. The process starts with mvn release:prepare,
   which verifies the code, removes the -SNAPSHOT suffix from the version, commits this final release version, and creates an SCM tag (like v1.0.0) in Git. 
   Following this, release:prepare automatically increments the version to the next -SNAPSHOT (e.g., 1.0.1-SNAPSHOT) and commits it, leaving the code ready for new development.
   Finally, mvn release:perform checks out the newly created tag, builds the definitive release artifacts, and deploys them to the Release Repository.

8. What is the significance of the verify phase in the build life cycle for CI/CD?

   The verify phase is the final quality gate in the Maven build life cycle before deployment in CI/CD. It primarily runs quality checks(e.g., code coverage, security scans) 
   on the packaged artifact, often executing any Integration Tests to ensure all parts of the application work together correctly. Passing this phase means 
   the built .jar or .war file meets all defined standards (including successful tests and code quality audits). Its significance lies in ensuring that only 
   a validated, production-ready artifact proceeds to the subsequent install and deploy stages. This guarantees the integrity and reliability of the Continuous Delivery pipeline.

9. How do you publish a finalized artifact to a remote Nexus/Artifactory repository? What POM and settings.xml changes are needed?

  The <distributionManagement> section in the POM specifies the remote repository URL for both releases and snapshots.
  The required authentication credentials (username/password/API key) are defined in the organization's global or user-specific settings.xml file
  using a matching <server> ID. The mvn deploy command then uses this configuration.

10. How do you address the "diamond dependency problem" or dependency version conflicts in a large project?

    The "diamond dependency problem" occurs when your project ends up relying on two different versions of the same transitive library
    (e.g., your project needs A and B, but A needs Library X v1.0 and B needs Library X v2.0). To resolve this in a large project,
    the primary method is Dependency Mediation, where you explicitly declare the single, desired version of the conflicting library 
    directly in your top-level <dependencies> section; Maven's "nearest wins" rule will then prioritize this direct declaration over
    any conflicting transitive versions. For multi-module projects, the best practice is to centralize the chosen version within the 
    parent POM's <dependencyManagement> section, enforcing version consistency across all modules.

11. Describe your first step when troubleshooting a build failure on a CI server that works fine locally.

    I first run the build with the -X (debug) or -e (error) flags on the CI server. The most common causes are environment differences 
    (JDK version, missing environment variables), the local machine using an old artifact in the local repository (CI starts with a fresh workspace),
    or a network issue preventing dependency downloads.


12. Explain the goal of the mvn clean install command. Why is the clean part often a necessity?

    mvn clean deletes the target directory, removing all previous build artifacts. install executes all phases up to install (compile, test, package, etc.), 
    which copies the final artifact into the local Maven repository. Running clean ensures that the build starts from a pristine state, preventing the use
    of stale or partially built classes from a previous build run.

13. How do you integrate security checks into a Maven build using a plugin?

    You integrate security checks by adding a vulnerability scanning plugin to your pom.xml. The most common choice is the OWASP Dependency-Check plugin .
    This plugin runs during a standard build phase (like verify), scanning all your third-party dependencies against public databases for known
    Common Vulnerabilities and Exposures (CVEs). Crucially, you configure it to fail the build if any vulnerability exceeds a set severity score
    (CVSS threshold), preventing risky code from reaching production and enforcing a "security gate."


14. What is the mvn wrapper and why is it a best practice for a DevOps project?

    The Maven Wrapper (mvnw) is a little script you add to your project. Its job is to make sure that everyone—every developer and every automated server—uses
    the exact same version of Maven to build the code. This is vital for DevOps because it eliminates the classic "it works on my machine, but not the server"
    problem by forcing consistent, reliable builds everywhere.

15. What are Nexus Cleanup Policies, and what problem do they solve?

    Cleanup Policies are rules configured in Nexus to automatically delete old, unused, or space-consuming artifacts.
    They primarily solve the problem of disk space exhaustion and build clutter. For example, a policy might be set to automatically
    delete Snapshots older than 30 days or keep only the last 5 builds of a specific artifact.

16. In a CI pipeline using Jenkins, what is the best practice for storing Nexus credentials?

    The best practice is never to hardcode credentials in the settings.xml or the Jenkinsfile. Instead, use the Jenkins Credentials Plugin
    to securely store the Nexus username and password/API key. These credentials are then injected into the build environment
    (e.g., as environment variables or using the withCredentials step) to dynamically generate the necessary settings.xml on the fly for the Maven build.

               
